1.尽量不要引入会使用到lib的函数，这样编译出来的文件就还需要Link to lib。导致kernel.bin大到几百kB

2.变量在使用前要显式初始化。因为loader并没有帮我们初始化。（我们知道一个程序已初始化值是定义了并且OS的loader会帮忙的。）

3.当你发现怎么调都调不对的时候，建议看看调用的汇编函数，对除了eax,ecx,edx（这些由调用者维护）的寄存器，是否在汇编中进行了保存与恢复。rust似乎在尽量使用各种寄存器，优化性能。比如作者的disp_str就没有保存edi，而rust传参使用了edi，此时就会出错。原版C对寄存器的利用或许没有那么高。

4.注意rust的指针。指向一个变量的指针用as *const T 或者*mut T 注意这个变量的语义是什么。函数要使用这个变量的值还是变量地址。以及变量里面存的是地址还是什么东西。汇编对某些LABEL就是地址。[LABEL]就是变量值。

5.在使用新的DT_PTR填充方法中。注意结构体的对齐。不写repr(C)的话结构体结构是不确定的（似乎来自rust doc）。而不写packed(2)的话那他会根据最大T对齐。在填充语义下是不对的。

6.对数组索引，不要使用参数作为下标。也就是编译时不确定的或者函数不确定的。此时rust认为需要判断这个索引是否越界，从而引入一些你没有实现的rust bound_check相关函数。

如果一定要使用 可以利用判断if let Some(x) = arr.get(i) 然后进行处理。

7.要取参数的话，push完所有要保存的寄存器再用ebp取。这是一个不能忽略的点。

8.鼠标中断要开启，必须键盘IRQ也不屏蔽。记得鼠标中断的从片也要发EOI。

9.[Consider deprecation of UB-happy `static mut` · Issue #53639 · rust-lang/rust](https://github.com/rust-lang/rust/issues/53639)
