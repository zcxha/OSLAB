use core::ffi::CStr;

use crate::{
    consts::{INT_M_CTL, INT_S_CTL},
    inc::{inb, outb},
    scrout::{print, print_int},
};

static mut MOUSE_CYCLE: u8 = 0;
static mut MOUSE_BYTE: [u8; 3] = [0; 3];
static mut MOUSE_X: u8 = 0;
static mut MOUSE_Y: u8 = 0;

fn pr(s: &CStr, value: u8) {
    print(s);
    print_int(value as u32);
    print(c"\n");
}
// Generated by GPT.
pub fn mouse_handler() {
    unsafe {
        match MOUSE_CYCLE {
            0 => {
                let b = inb(0x60);
                // 校验同步位
                if (b & 0x08) == 0 {
                    return;
                }
                MOUSE_BYTE[0] = b;
                MOUSE_CYCLE = 1;
            }
            1 => {
                MOUSE_BYTE[1] = inb(0x60);
                MOUSE_CYCLE = 2;
            }
            2 => {
                MOUSE_BYTE[2] = inb(0x60);
                MOUSE_X = MOUSE_BYTE[1];
                MOUSE_Y = MOUSE_BYTE[2];
                MOUSE_CYCLE = 0;

                pr(c"x: ", MOUSE_X);
                pr(c"y: ", MOUSE_Y);
            }
            _ => {
                MOUSE_CYCLE = 0;
            }
        }

        // 发送中断结束信号给从、主PIC
        outb(INT_S_CTL, 0x20);
        outb(INT_M_CTL, 0x20);
    }
}

fn mouse_wait(a_type: u8) // unsigned char
{
    let _time_out = 100000; // unsigned int
}

fn mouse_write(a_write: u8) // unsigned char
{
    // Wait to be able to send a command
    mouse_wait(1);
    // Tell the mouse we are sending a command
    outb(0x64, 0xD4);
    // Wait for the final part
    mouse_wait(1);
    // Finally write
    outb(0x60, a_write);
}

fn mouse_read() -> u8 {
    // Get's response from mouse
    mouse_wait(0);
    return inb(0x60);
}

pub fn mouse_install() {
    unsafe { MOUSE_CYCLE = 0 };

    let mut _status = 0; // unsigned char

    // Enable the auxiliary mouse device
    mouse_wait(1);
    outb(0x64, 0xA8);

    // Enable the interrupts
    mouse_wait(1);
    outb(0x64, 0x20);
    mouse_wait(0);
    _status = inb(0x60) | 2;
    mouse_wait(1);
    outb(0x64, 0x60);
    mouse_wait(1);
    outb(0x60, _status);

    // Tell the mouse to use default settings
    mouse_write(0xF6);
    mouse_read(); // Acknowledge

    // Enable the mouse
    mouse_write(0xF4);
    mouse_read(); // Acknowledge

    // Setup the mouse handler
}
