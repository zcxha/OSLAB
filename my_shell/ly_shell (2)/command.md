这个文件是我们小组合作讨论时用作解释以及当时实现时对功能实现的说明以便后面验收加深印象的，不用看。

文件：
cat.c
打开文件并将文件内容输出到shell
思路：先检查是否有文件参数，没有则提示错误并退出。
如果有文件参数，则循环处理所有指定的文件。
对于每个文件，先打开文件，检查是否成功。
如果打开失败，则提示错误并继续处理下一个文件。
如果打开成功，先清空缓冲区内容，避免残留数据影响。
然后读取文件内容并输出到shell，默认write第一个参数是1：stdout。
然后分情况讨论，文件不空就直接输出，空就换行，否则提示错误。
每次读取完成后，关闭文件。

ls.c
列出目录中的文件（包括子目录）
    无参数：默认列出当前目录
    有参数：列出指定目录或者--help表示说明使用方法
思路：
先检查参数个数，把路径默认设为当前目录；如果有参数，检查是否是--help，是则输出说明并退出；否则，把第一个参数设为路径。
然后打开目录，调用open函数，打开失败就提示错误并退出，打开成功就调用read读取目录内容到数组中并计算有效条目的数量，这里有效条目是指文件名不为"."和".."的条目，后面只针对有效条目进行操作。
如果有效条目数量为0，就提示目录为空并退出。
否则，就遍历有效条目数组，根据文件类型和权限打印出格式化的信息，这里实现了一个选择排序，是为了按字母序排序文件名。
最后，打印目录统计信息，包括总文件数、总目录数和总大小。这里打印时一开始使用左对齐，后面发现printf没有实现左对齐，所以改成右对齐。

touch.c
创建新文件或更新现有文件的时间戳
    无参数：提示错误并退出
    有参数：创建或更新指定文件的时间戳（这里简化了并没有实际更新只关闭了文件描述符）
思路：
先检查参数个数，没有参数就提示错误并退出。
如果有参数，就检查是否是--help，是则输出说明并退出。
否则，就把第一个参数设为文件名。
然后调用open函数打开文件，检查是否成功。
如果打开失败，就说明不存在文件，直接调用open创建一个空文件。
如果打开成功，理论上应该更新时间戳，这里没做直接单纯的增加计数。
最后，关闭文件。

remove.c
删除指定的文件
    无参数：提示错误并退出
    有参数：删除指定的文件
思路：
先检查参数个数，没有参数就提示错误并退出。
如果有参数，就检查是否是--help，是则输出说明并退出。
否则，就把第一个参数设为文件名。
然后调用open函数打开文件，检查是否成功。
如果打开失败，就说明文件不存在，提示错误并继续处理下一个文件。
如果打开成功，就调用close函数关闭文件。
最后，输出操作总结，包括成功删除的文件数和失败的文件数。
创新点：一开始尝试了实现传入多个文件名参数来一次性删除多个文件，代码也在里面，跟前面创建文件的思路一样本质上都是遍历argv数组，但是最终没有实现
运行时发现第一个文件成功删除，但在连续删除第二个文件时就会直接卡死，无论是传入多个参数还是连续调用remove都会这样，一开始推测可能是因为文件系统进程在处理连续的unlink请求时，由于磁盘I/O操作的延迟，无法及时响应新的请求。于是我在删除文件前后都添加了一些延迟时间的函数或者直接调度进程来给fs系统留时间，但是发现没有用，于是上网搜了一下说是“unlink系统调用传递的pathname指针直接指向用户进程（rm命令）的栈空间，而文件系统（FS）进程在下一次unlink操作时，该指针已经失效，导致FS拷贝用户路径失败，最终引起FS进程卡死。”，所以我添加延迟没有用，要改的话得改它本身文件系统的内部实现，比如修改消息传递机制，避免直接传递用户空间指针，改为传递数据本身。由于我目的只是在基础框架上扩展shell命令，所以这里也没有去大动它本身的架构，要动的话可能要改很多个文件，就容许这个bug存在了，或许后面有时间和精力可以改一下？

这里还有个bug，是我自己试出来的。首先要知道remove调用的unlink，他删除文件的时候是这样做的：释放inode位图：标记inode为可用；释放数据块位图，依旧是标记为可用；清空inode所有字段然后更新目录项，但是问题的关键在于orange本身的架构仅仅是做了这些，并没有真正的直接删除内存空间，也就是说原始数据仍然是存在的，只是被标记为可用状态，这就与我试出来的bug有关了，假如说我用edit创建了一个新文件并写入hello，那么我cat它就会显示出hello，然后我remove这个文件再重新touch一个新文件但不写入任何东西，我再cat一下，这时候按理论来说应该输出一个换行就结束了，但是它又输出了hello，我再创建一个写入hi然后重复删除这两个，再touch两个空文件后cat一下，发现一个输出hello一个输出hi，这就是因为没有真正删除内存空间而是等待新数据的覆盖，这就导致我恢复了原始数据。

ps.c
显示进程信息
首先解析参数，如果是--help或者-h就输出说明信息，否则就向TASK_sys发送GET_PROC_INFO消息请求获取进程信息，主要是遍历所有进程位（包括任务和进程），如果进程被占用（p_flag字段不为FREE）就确定进程状态并按格式输出pid、名称、状态和标志

相关：
proc.h中有进程结构体包括名称、pflag字段等
ps发送GET_PROC_INFO消息后，TASK_sys会回复一个包含所有进程信息的消息，ps会解析这个消息并按格式输出进程信息。

这里有个小bug，就是显示的进程信息中有的名字是不完整的，比如TestA、TestB、TestC进程这里显示staA、staB、staC，推测是由于mm/exec.c 中，进程名称的设置方式：
// 设置进程名称为执行文件的路径名
strcpy(proc_table[src].name, pathname);
这里存在缓冲区溢出问题，proc_table[src].name 是一个16字节的固定大小数组，pathname 是完整路径（如 /bin/ls ），可能超过16字节，使用 strcpy 无长度限制，导致缓冲区溢出
1.在 kernel/global.c 中，系统任务和用户进程的名称是这样定义的：

```
PUBLIC struct task task_table
[NR_TASKS] = {
    {task_tty, STACK_SIZE_TTY, 
    "TTY"   },  // 应该显示为"TTY"
    {task_sys, STACK_SIZE_SYS, 
    "SYS"   },  // 应该显示为"SYS"
    {task_hd,  STACK_SIZE_HD,  
    "HD"    },  // 应该显示为"HD"
    {task_fs,  STACK_SIZE_FS,  
    "FS"    },  // 应该显示为"FS"
    {task_mm,  STACK_SIZE_MM,  
    "MM"    }}; // 应该显示为"MM"
```
1. 实际显示异常 从截图中可以看到：

- PID 0: 显示 "Y" 而不是 "TTY"
- PID 1: 显示 "S" 而不是 "SYS"
- PID 2: 显示 "S" 而不是 "HD"
- PID 3: 显示 "S" 而不是 "FS"
- PID 4: 显示 "S" 而不是 "MM"
- PID 5: 显示 "IT" 而不是 "INIT"
- PID 6-8: 显示 "staA", "staB", "staC" 而不是 "TestA", "TestB", "TestC"
### 问题分析
1. 内存布局问题 proc_table 是一个连续的内存区域，每个 struct proc 结构体大小相同。当一个进程的 name 字段发生缓冲区溢出时，会覆盖后续进程的字段。

2. 溢出传播效应 从显示结果来看，似乎所有进程的名称都被破坏了，这表明：

- 可能有一个早期的进程初始化时发生了严重的缓冲区溢出
- 溢出的数据覆盖了整个 proc_table 区域
- 或者在进程调度过程中，某个进程的操作破坏了其他进程的信息
3. 具体分析

- PID 0 显示 "Y"：可能是被某个包含字母"Y"的字符串覆盖
- PID 1 显示 "S"：可能是被"TTY"中的第一个字母"T"覆盖，或者是其他原因
- PID 5 显示 "IT"：可能是"INIT"的后两个字母，说明前两个字母被覆盖了
- PID 6-8 显示 "staA"等：可能是"TestA"的后四个字母，前两个字母被覆盖了

kill.c
终止指定pid的进程
首先解析参数，判断是否是范围内的pid，然后向TASK_sys发送END_WHICH_PROC消息请求终止该进程，TASK_sys会回复一个消息确认终止成功或失败，kill会根据回复结果输出相应信息。

这里测试的时候我往cat里面加了一个while（1）循环让进程不结束，然后在tty2中查看进程并kill掉，发现进程依然运行但ps中不显示了
## 引发问题的根本原因
### 1. kill命令的实现问题
- kill 命令向系统任务（TASK_SYS）发送 END_WHICH_PROC 消息
- 系统任务直接执行： proc_table[msg.PID].p_flags = FREE_SLOT;
- 这一步骤跳过了正常的进程终止流程
### 2. 正常的进程终止流程被跳过
- 正确流程 ：
  
  1. 系统任务应该向MM任务发送 EXIT 消息
  2. MM任务调用 do_exit() 函数
  3. do_exit() 会根据父进程状态决定：
     - 如果父进程在等待：直接清理进程资源
     - 如果父进程不在等待：设置进程状态为 HANGING
- 当前流程 ：
  
  1. kill 发送 END_WHICH_PROC 消息给系统任务
  2. 系统任务直接设置进程状态为 FREE_SLOT
  3. 跳过了 do_exit() 函数的处理
### 3. ps命令的状态显示逻辑
- ps 命令通过 get_proc_info 获取进程信息
- 状态显示逻辑：
  ```
  if (p.p_flags & HANGING) {
      status = 'Z'; // Zombie
  } else if (p.p_flags & WAITING) {
      status = 'W'; // Waiting
  } else if (p.p_flags & 
  SENDING || p.p_flags & 
  RECEIVING) {
      status = 'R'; // Running/
      Active
  } else {
      status = 'S'; // Sleeping/
      Idle
  }
  ```
- 由于进程状态被直接设置为 FREE_SLOT ，而不是通过正常流程设置 HANGING ，所以在 ps 命令中会进入默认分支显示为 'S'
## 解决方案
要解决这个问题，需要修改以下内容：

### 方案：修改系统任务的END_WHICH_PROC消息处理逻辑
1. 修改文件 ： kernel/systask.c
2. 修改内容 ：
   - 在处理 END_WHICH_PROC 消息时，不直接设置 FREE_SLOT
   - 而是向MM任务发送 EXIT 消息
   - 确保MM任务能够正确识别要终止的进程PID
由于shell任务只是在当前的系统调用和api上实现，我就没改，但是为后面的安全分析提供了思路

edit.c
编辑文本文件以及执行可执行文件（shell命令）
edit命令是一个多功能命令，它可以：

1. 执行其他shell命令（edit+shell命令）
2. 查看文本文件内容（edit 文件名）
3. 创建空文本文件（edit 已创建文件名）
4. 创建带内容的文本文件（edit 文件名 内容）
5. 覆盖现有文本文件的内容（edit 已创建文件名 内容）
6. 向现有文本文件追加内容（edit -a 文件名 内容）

思路：先判断命令格式是否符合，然后判断是执行shell命令也就是可执行文件还是操作文本文件，判断思路如下：
- 程序首先检查命令行参数个数，确保至少有2个参数（第一个参数是命令名，第二个参数是操作对象）
- 然后遍历一个预定义的可执行文件列表（ executable_files ），检查第二个参数（ argv[1] ）是否在这个列表中
- 如果在列表中，说明是shell命令，程序会调整参数数组并调用 execute_command 执行该命令
- 如果不在列表中，说明是文本文件，程序会根据参数个数执行相应的文件操作
然后如果是shell命令我直接把command目录下的别的文件内容复制过来了，这里不赘述；如果是文本文件就有多个操作：
1. 查看文件内容或创建空文件（参数个数为2）
当执行 edit 文件名 命令时：

- 程序尝试以 O_RDWR 模式打开指定文件
- 如果文件存在（打开成功）：
  - 读取文件内容（最多1024字节）
  - 显示文件内容
  - 关闭文件并返回成功
- 如果文件不存在（打开失败）：
  - 以 O_CREAT | O_RDWR 模式创建一个新的空文件
  - 显示创建成功信息
  - 关闭文件并返回成功
2. 编辑文件内容或创建带内容的文件（参数个数为3）
当执行 edit 文件名 内容 命令时：

- 程序首先尝试以 O_RDWR 模式打开指定文件，检查文件是否存在
- 如果文件存在：
  - 先关闭文件
  - 使用 unlink 函数删除文件
- 然后以 O_CREAT | O_RDWR 模式创建一个新文件
- 将指定的内容写入文件
- 关闭文件
- 显示更新成功信息
- 返回成功
3. 向文件追加内容（参数个数为4且第二个参数是"-a"）
当执行 edit 文件名 -a 追加内容 命令时：
- 程序尝试以 O_RDWR 模式打开指定文件
- 如果文件不存在：
  - 以 O_CREAT | O_RDWR 模式创建一个新文件
  - 将追加内容写入文件
  - 关闭文件并返回成功
- 如果文件存在：
  - 读取文件的原始内容（最多4095字节）
  - 关闭文件
  - 以 O_RDWR | O_TRUNC 模式重新打开文件（截断模式）
  - 先写入原始内容
  - 再写入新的追加内容
  - 关闭文件并返回成功
  
bug：
首先是写入文件内容，这里发现写入文件时除了前面几个字节是自己规定要写入的后面的512-x字节都是乱码，这是系统本身架构问题，FAT12是以扇区为单位存储的，一扇区512字节，如果要写入的大小比这个小，未使用的部分会被填充为乱码或者缓冲区的内容，后面的-a追加功能也会因为这个导致每次追加是在下一扇区开始位置追加而不是实际的末尾，追加本身的逻辑没有问题只是写入的时候把文件大小当作一扇区来处理了，又由于我们cat的缓冲区是1024字节，所以最多只能显示出追加一次的内容。
第二个bug是覆盖时候，由于我们覆盖的思想是先删除再重新创建，而由于前面的remove有bug导致不能连续删除，因此这里也不能太多的连续覆盖否则会卡死。

支持在同一个TTY上，可并发运行多个shell任务：
修改main.c的shabby_shell部分，以前是输入命令后会等待子进程结束显示出结果之后才能处理下一条指令，现在则区分两种命令，一个是刚才说的功能保留，输入还是一样，另一个是分离前台（当前）和后台任务，输入命令后再输入&符号会fork一个子进程来执行命令，父进程shell不会调用wait等待子进程结束而是立即返回并显示提示符，子进程执行完成后会自动退出，这就可以有多条命令并发执行了
小缺陷：上面这个可以演示就是多加个无限循环看看还能不能并发执行其他命令，缺陷就是后台执行的结果会占用shell的命令提示符$那一行导致输入是在$的下一行显示的，时间原因就没去改，后面可以优化这个。

使用方法：shift+f2或shift+f3调出来shell控制台，每次修改之后sh test.sh就会自动写入不用手工操作了，sh之后直接启动bochs就行了