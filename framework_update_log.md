# OrangeOS 框架架构升级日志

本文档记录了针对实验任务要求对 OrangeOS 原始框架进行的底层优化与功能扩展。本次修改在不影响已有的 `command` 扩展、日志系统和小游戏功能的前提下，重点改进了内存管理与进程调度算法。

## 1. 内存管理系统优化 (Memory Management)

### 1.1 背景与问题
原始框架中的 `mm/main.c` 采用了极其简化的静态内存分配策略：
- `alloc_mem`: 基于 PID 硬编码计算物理地址偏移，每个进程分配固定的 `PROC_IMAGE_SIZE_DEFAULT` (1MB) 空间。
- `free_mem`: 实际上不执行任何操作，无法回收内存。
这种策略导致了内存利用率低下（碎片化严重）且缺乏灵活性。

### 1.2 改进方案：首次适应 (First-Fit) 动态分配算法
在 [mm/main.c](file:///h:/迅雷下载/OSLAB-mo(1)/OSLAB-mo/mm/main.c) 中实现了真正的动态内存管理：
- **内存映射表 (`mem_map`)**: 引入了 `struct mem_block` 结构体数组，用于追踪系统中所有空闲和已占用的内存块。
- **动态分配 (`alloc_mem`)**: 
    - 遍历 `mem_map` 寻找第一个满足大小要求的空闲块。
    - 支持**块拆分 (Splitting)**：如果找到的空闲块大于请求大小，则将其拆分为“已分配”和“剩余空闲”两个块，提高空间利用率。
- **内存释放与合并 (`free_mem`)**:
    - 根据 PID 标记对应的内存块为空闲。
    - 支持**相邻块合并 (Merging)**：释放内存后，自动检查并合并物理地址相邻的空闲块，有效减少外部碎片。

## 2. 进程调度算法优化 (Process Scheduling)

### 2.1 背景与问题
原始调度算法仅基于简单的 `ticks` 优先级：
- 当所有进程的 `ticks` 耗尽时，重新根据 `priority` 赋值。
- 这种方式虽然简单，但在多进程环境下可能导致低优先级进程因长期无法获得足够时间片而出现“饥饿”现象。

### 2.2 改进方案：引入老化机制 (Aging)
在 [kernel/proc.c](file:///h:/迅雷下载/OSLAB-mo(1)/OSLAB-mo/kernel/proc.c) 的 `schedule()` 函数中引入了老化机制，增加了调度的复杂性和公平性：
- **动态优先级提升**: 每次调度器选择一个进程运行后，会遍历其他所有处于“就绪”状态 (`p_flags == 0`) 的进程。
- **补偿机制**: 对那些已就绪但未被选中的进程，其 `ticks` 会获得小幅度的提升（最高可提升至其初始优先级的 2 倍）。
- **效果**: 保证了即使是低优先级的进程，在等待足够长的时间后，其有效优先级也会逐渐升高，从而最终获得执行机会，彻底解决了饥饿问题。

## 3. 兼容性保证

- **无破坏性修改**: 所有修改均位于 `mm/` 和 `kernel/` 目录下的框架源码中。
- **API 保持一致**: `alloc_mem`, `free_mem` 和 `schedule` 的接口未变，原有的 `fork`, `exec`, `exit` 等系统调用逻辑完全兼容。
- **独立性**: 未触及 `command/` 目录下的任何 shell 指令代码，也未修改用户自定义的日志逻辑 (`log_process` 等开关及其存储逻辑保持原样）。
- **稳定性**: 改进后的算法在逻辑上更加严谨，提升了系统的健壮性和资源调度效率。
